// Generated by CoffeeScript 1.12.7
(function() {
  var BBox, Bend, Crossover, Join, Merge, Piece, Split, Straight, Track, TrackPainter, Transform, root, transformsMeet,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Track = (function() {
    var Section;

    function Track(start1, options) {
      var ref, ref1, ref2;
      this.start = start1 != null ? start1 : new Transform(0, 0, 0);
      if (options == null) {
        options = {};
      }
      this.gridSize = (ref = options.gridSize) != null ? ref : 100;
      this.trackWidth = (ref1 = options.trackWidth) != null ? ref1 : 16;
      this.trackGap = (ref2 = options.trackGap) != null ? ref2 : 1;
      this._sections = [];
      this._listeners = {};
      this._gapTransform = new Transform(this.trackGap, 0, 0);
      this.started = null;
    }

    Track.prototype.on = function(types, listener) {
      return types.split(" ").forEach((function(_this) {
        return function(type) {
          if (_this._listeners[type] == null) {
            _this._listeners[type] = [];
          }
          return _this._listeners[type].push(listener);
        };
      })(this));
    };

    Track.prototype.off = function(types, listener) {
      return types.split(" ").forEach((function(_this) {
        return function(type) {
          var i, idx, l, len, ref, results;
          ref = _this._listeners[type];
          results = [];
          for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
            l = ref[idx];
            if (l === listener) {
              results.push(_this._listeners[type].splice(idx, 1));
            }
          }
          return results;
        };
      })(this));
    };

    Track.prototype._fire = function(event) {
      if (typeof event === "string") {
        event = {
          type: event
        };
      }
      if (!event.target) {
        event.target = this;
      }
      if (!event.type) {
        throw new Error("Event missing 'type' property.");
      }
      if (this._listeners[event.type] instanceof Array) {
        return this._listeners[event.type].forEach(function(listener) {
          return listener.call(this, event);
        });
      }
    };

    Track.prototype.set = function(property, value) {
      if (value !== this[property]) {
        this[property] = value;
        switch (property) {
          case 'trackGap':
            this._gapTransform = new Transform(value, 0, 0);
        }
        return this._fire({
          type: 'change',
          target: this
        });
      }
    };

    Track.prototype.clone = function() {
      var i, len, ref, result, section;
      result = new Track(this.start, this);
      ref = this._sections;
      for (i = 0, len = ref.length; i < len; i++) {
        section = ref[i];
        result._sections.push(section.clone(result));
      }
      return result;
    };

    Track.prototype.connections = function() {
      var offset, result;
      result = [];
      offset = 0;
      this._sections.forEach(function(section) {
        section.connections().forEach(function(code) {
          var index, letter, ref;
          ref = code.split(':'), index = ref[0], letter = ref[1];
          return result.push((parseInt(index) + offset).toString() + ":" + letter);
        });
        return offset += section._pieces.length;
      });
      return result;
    };

    Track.prototype.pieces = function() {
      var result;
      result = [];
      this._sections.forEach(function(section) {
        return result = result.concat(section._pieces);
      });
      return result;
    };

    Track.prototype.add = function(piece, where) {
      var section;
      if (piece instanceof Piece) {
        if (where != null) {
          if (where instanceof Transform) {
            section = this._createSection(function() {
              return where;
            });
            piece.setSection(section);
            return this._firePieceAdded(piece);
          } else {
            throw new Error('the second parameter should be a transform - perhaps you need to use the connect method?');
          }
        } else if (this.connections().length === 0 && (this.started == null)) {
          section = this._createSection((function(_this) {
            return function() {
              return _this.start;
            };
          })(this));
          piece.setSection(section);
          this._firePieceAdded(piece);
          return this.started = piece;
        } else if (this.cursor() != null) {
          return this.connect(piece, this.cursor());
        } else {
          throw new Error('unable to add piece - try specifying the where parameter in the track.add method');
        }
      } else {
        throw new Error('the first parameter should be a piece');
      }
    };

    Track.prototype.cursor = function() {
      var code, conns, piece, section;
      section = this._sections[this._sections.length - 1];
      if (section != null) {
        piece = section._pieces[section._pieces.length - 1];
      }
      if (piece != null) {
        code = this._index(piece) + ":" + piece.exit;
      }
      conns = this.connections();
      if ((code != null) && conns.indexOf(code) > -1) {
        return code;
      } else {
        return conns.pop();
      }
    };

    Track.prototype.connect = function(piece, code) {
      var added, index, label, ref, ref1, section, sectionIndex, sectionPieceIndex;
      if (piece instanceof Piece) {
        if (this.connections().indexOf(code) > -1) {
          added = false;
          this._sections.forEach((function(_this) {
            return function(section) {
              var last, lastExit, length;
              length = section._pieces.length;
              last = section._pieces[length - 1];
              lastExit = (_this._sectionStartingIndex(section) + length - 1) + ":" + last.exit;
              if (lastExit === code) {
                added = true;
                piece.setSection(section);
                return _this._firePieceAdded(piece);
              }
            };
          })(this));
          if (!added) {
            ref = code.split(':'), index = ref[0], label = ref[1];
            ref1 = this._sectionAndPieceIndex(index), sectionIndex = ref1[0], sectionPieceIndex = ref1[1];
            section = this._createSection((function(_this) {
              return function() {
                return _this._sections[sectionIndex].compoundTransform(sectionPieceIndex, label).compound(_this._gapTransform);
              };
            })(this));
            this._connection(code).connected = piece.connections['A'];
            piece.connections['A'].connected = this._connection(code);
            piece.setSection(section);
            return this._firePieceAdded(piece);
          }
        } else {
          throw new Error(code + " is not an available connection");
        }
      } else {
        throw new Error('the first parameter should be a piece');
      }
    };

    Track.prototype.remove = function(index) {
      var pieceIndex, ref, sectionIndex;
      ref = this._sectionAndPieceIndex(index), sectionIndex = ref[0], pieceIndex = ref[1];
      this._sections[sectionIndex].remove(pieceIndex);
      return this._fire({
        type: 'remove',
        target: this
      });
    };

    Track.prototype.clear = function() {
      this._sections = [];
      this._fire({
        type: 'clear',
        target: this
      });
      return this.started = null;
    };

    Track.prototype.collisions = function() {
      var i, idx, idx2, j, len, len1, pieces, ref, result, source, target;
      pieces = [];
      this._sections.forEach((function(_this) {
        return function(section) {
          var start;
          start = section.transform();
          return section._pieces.forEach(function(piece) {
            piece._setBBox(start);
            start = start.compound(piece.exitTransform()).compound(_this._gapTransform);
            return pieces.push(piece);
          });
        };
      })(this));
      result = [];
      for (idx = i = 0, len = pieces.length; i < len; idx = ++i) {
        source = pieces[idx];
        ref = pieces.slice(idx + 1);
        for (idx2 = j = 0, len1 = ref.length; j < len1; idx2 = ++j) {
          target = ref[idx2];
          if (source._bbox.overlaps(target._bbox)) {
            result.push([idx, idx2 + idx + 1]);
          }
        }
      }
      return result;
    };

    Track.prototype.hasCollision = function() {
      return this.collisions().length > 0;
    };

    Track.prototype.connected = function(a, b) {
      var connection, label, ref;
      ref = a.connections;
      for (label in ref) {
        connection = ref[label];
        if (connection.connected === b) {
          return true;
        }
      }
      return false;
    };

    Track.prototype._firePieceAdded = function(piece) {
      var idx, transform;
      idx = this._index(piece);
      transform = this._transform(idx.toString() + ":A");
      return this._fire({
        type: 'add',
        target: piece,
        start: transform.compound(new Transform(0, 0, 180))
      });
    };

    Track.prototype._sectionAndPieceIndex = function(index) {
      var result, sectionIdx;
      result = null;
      sectionIdx = 0;
      this._sections.forEach(function(section) {
        if (index < section._pieces.length && (result == null)) {
          return result = [sectionIdx, index];
        } else {
          index -= section._pieces.length;
          return sectionIdx++;
        }
      });
      return result;
    };

    Track.prototype._sectionStartingIndex = function(section) {
      var fn, i, idx, ref, result;
      result = 0;
      if (this._sections.length > 0) {
        fn = (function(_this) {
          return function(idx) {
            return result += _this._sections[idx]._pieces.length;
          };
        })(this);
        for (idx = i = 0, ref = this._sections.indexOf(section); 0 <= ref ? i < ref : i > ref; idx = 0 <= ref ? ++i : --i) {
          fn(idx);
        }
      }
      return result;
    };

    Track.prototype._index = function(piece) {
      var i, idx, len, p, ref, result;
      result = -1;
      ref = this.pieces();
      for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
        p = ref[idx];
        if (piece === p) {
          result = idx;
        }
      }
      return result;
    };

    Track.prototype._piece = function(index) {
      var pieceidx, ref, sectionidx;
      ref = {
        _sectionAndPieceIndex: index
      }, sectionidx = ref[0], pieceidx = ref[1];
      return this._sections[sectionidx]._pieces[pieceidx];
    };

    Track.prototype._connection = function(code) {
      var index, letter, ref, ref1, sectionIndex, sectionPieceIndex;
      ref = code.split(':'), index = ref[0], letter = ref[1];
      ref1 = this._sectionAndPieceIndex(parseInt(index)), sectionIndex = ref1[0], sectionPieceIndex = ref1[1];
      return this._sections[sectionIndex]._pieces[sectionPieceIndex].connections[letter];
    };

    Track.prototype._createSection = function(transform) {
      var section;
      if (transform == null) {
        transform = null;
      }
      section = new Section(this, transform);
      this._sections.push(section);
      return section;
    };

    Track.prototype._closeLoops = function() {
      var i, loose, ref, results;
      loose = this.connections();
      return (function() {
        results = [];
        for (var i = 0, ref = loose.length; 0 <= ref ? i < ref : i > ref; 0 <= ref ? i++ : i--){ results.push(i); }
        return results;
      }).apply(this).forEach((function(_this) {
        return function(idx1) {
          var i, ref, ref1, results;
          return (function() {
            results = [];
            for (var i = ref = idx1 + 1, ref1 = loose.length; ref <= ref1 ? i < ref1 : i > ref1; ref <= ref1 ? i++ : i--){ results.push(i); }
            return results;
          }).apply(this).forEach(function(idx2) {
            var trans1, trans2;
            trans1 = _this._transform(loose[idx1]);
            trans2 = _this._transform(loose[idx2]).compound(_this._gapTransform);
            if (transformsMeet(trans1, trans2)) {
              _this._connection(loose[idx1]).connected = _this._connection(loose[idx2]);
              _this._connection(loose[idx2]).connected = _this._connection(loose[idx1]);
              return _this._closeLoops;
            }
          });
        };
      })(this));
    };

    Track.prototype._transform = function(code) {
      var index, label, ref, ref1, sectionIndex, sectionPieceIndex;
      ref = code.split(':'), index = ref[0], label = ref[1];
      ref1 = this._sectionAndPieceIndex(index), sectionIndex = ref1[0], sectionPieceIndex = ref1[1];
      return this._sections[sectionIndex].compoundTransform(sectionPieceIndex, label);
    };

    Section = (function() {
      function Section(track1, transform1) {
        this.track = track1;
        this.transform = transform1 != null ? transform1 : function() {
          return new Transform(0, 0, 0);
        };
        this._pieces = [];
        this.exit = null;
      }

      Section.prototype.clone = function(newtrack) {
        var i, len, piece, ref, result;
        result = new Section(newtrack, this.transform);
        ref = this._pieces;
        for (i = 0, len = ref.length; i < len; i++) {
          piece = ref[i];
          piece.clone(result);
        }
        return result;
      };

      Section.prototype.add = function(piece) {
        var num_pieces, section_offset;
        if (this._pieces.length > 0 && this.connections().length === 0) {
          throw new Error("No available connections on this section");
        }
        num_pieces = this._pieces.length;
        section_offset = this.track._sectionStartingIndex(this);
        piece.section = this;
        if (this.exit != null) {
          this.exit.connected = piece;
          piece.connections['A'].connected = this;
        }
        this.exit = piece.connections[piece.exit];
        this._pieces.push(piece);
        return piece;
      };

      Section.prototype.remove = function(idx) {
        var num_pieces, removee;
        if (typeof idx !== "number") {
          idx = this._pieces.indexOf(idx);
        }
        num_pieces = this._pieces.length;
        if (idx >= 0 && idx < num_pieces) {
          if (num_pieces === 1) {
            this.exit = null;
          } else {
            removee = this._pieces[idx];
            if (idx < (num_pieces - 1)) {
              this._pieces[idx + 1].connections['A'].connected = removee.connections['A'].connected;
            } else {
              this.exit = this._pieces[idx - 1].connections[this._pieces[idx - 1].exit];
            }
            if (idx > 0) {
              this._pieces[idx - 1].connections[this._pieces[idx - 1].exit].connected = removee.connections[removee.exit].connected;
            }
            removee.connections['A'].connected = null;
            removee.connections[removee.exit].connected = null;
          }
          this._pieces[idx].section = null;
          return this._pieces.splice(idx, 1);
        } else {
          throw new Error("Cannot remove piece " + idx + " from section with " + this._pieces.length + " pieces");
        }
      };

      Section.prototype.connections = function() {
        var connection, i, idx, label, len, piece, ref, ref1, result;
        result = [];
        ref = this._pieces;
        for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
          piece = ref[idx];
          ref1 = piece.connections;
          for (label in ref1) {
            connection = ref1[label];
            if (!connection.connected) {
              result.push(idx.toString() + ":" + label);
            }
          }
        }
        return result;
      };

      Section.prototype.compoundTransform = function(n, connection) {
        var i, results, start;
        start = this.transform();
        (function() {
          results = [];
          for (var i = 0; 0 <= n ? i < n : i > n; 0 <= n ? i++ : i--){ results.push(i); }
          return results;
        }).apply(this).forEach((function(_this) {
          return function(pieceIndex) {
            return start = start.compound(_this._pieces[pieceIndex].exitTransform()).compound(_this.track._gapTransform);
          };
        })(this));
        return start.compound(this._pieces[n].connections[connection].transform());
      };

      return Section;

    })();

    return Track;

  })();

  TrackPainter = (function() {
    function TrackPainter(track, options) {
      var ref, ref1, ref2, ref3, ref4, ref5, ref6;
      if (options == null) {
        options = {};
      }
      this.track = track;
      this.trackColor = (ref = options.trackColor) != null ? ref : "lightgrey";
      this.railColor = (ref1 = options.railColor) != null ? ref1 : "white";
      this.showCodes = (ref2 = options.showCodes) != null ? ref2 : true;
      this.showCursor = (ref3 = options.showCursor) != null ? ref3 : true;
      this.railWidth = (ref4 = options.railWidth) != null ? ref4 : 2;
      this.railGauge = (ref5 = options.railGauge) != null ? ref5 : 9;
      this.showBBox = (ref6 = options.showBBox) != null ? ref6 : false;
      this.draw();
    }

    TrackPainter.prototype.draw = function() {
      this._clear();
      this.track._sections.forEach((function(_this) {
        return function(section) {
          var start;
          start = section.transform();
          return section._pieces.forEach(function(piece) {
            if (_this.showBBox) {
              piece._setBBox;
            }
            piece.draw(_this, start);
            return start = start.compound(piece.exitTransform()).compound(_this.track._gapTransform);
          });
        };
      })(this));
      if (this.showCodes) {
        this.track.connections().forEach((function(_this) {
          return function(code) {
            return _this.drawCode(_this.track._transform(code).compound(_this.track._gapTransform), code);
          };
        })(this));
      }
      if (this.showCursor && this.track.cursor()) {
        return this.drawCursor(this.track._transform(this.track.cursor()));
      }
    };

    TrackPainter.prototype.set = function(property, value) {
      if (value !== this[property]) {
        this[property] = value;
        return this.draw();
      }
    };

    return TrackPainter;

  })();

  Transform = (function() {
    function Transform(translateX, translateY, rotateDegs) {
      this.translateX = translateX;
      this.translateY = translateY;
      this.rotateDegs = rotateDegs;
      this.rotateRads = this.rotateDegs * Math.PI / 180;
    }

    Transform.prototype.compound = function(transform) {
      return new Transform(this.translateX + Math.cos(this.rotateRads) * transform.translateX - Math.sin(this.rotateRads) * transform.translateY, this.translateY + Math.sin(this.rotateRads) * transform.translateX + Math.cos(this.rotateRads) * transform.translateY, (360 + this.rotateDegs + transform.rotateDegs) % 360);
    };

    Transform.prototype.toString = function() {
      return "(" + this.translateX + ", " + this.translateY + ", " + this.rotateDegs + ")";
    };

    return Transform;

  })();

  BBox = (function() {
    function BBox(x1, y1, x2, y2) {
      this.x1 = x1 != null ? x1 : null;
      this.y1 = y1 != null ? y1 : null;
      this.x2 = x2 != null ? x2 : null;
      this.y2 = y2 != null ? y2 : null;
    }

    BBox.prototype.addTransform = function(t) {
      if ((this.x1 == null) || t.translateX < this.x1) {
        this.x1 = t.translateX;
      }
      if ((this.x2 == null) || t.translateX > this.x2) {
        this.x2 = t.translateX;
      }
      if ((this.y1 == null) || t.translateY < this.y1) {
        this.y1 = t.translateY;
      }
      if ((this.y2 == null) || t.translateY > this.y2) {
        return this.y2 = t.translateY;
      }
    };

    BBox.prototype.overlaps = function(bbox) {
      if (bbox.x2 < this.x1) {
        return false;
      }
      if (bbox.x1 > this.x2) {
        return false;
      }
      if (bbox.y2 < this.y1) {
        return false;
      }
      if (bbox.y1 > this.y2) {
        return false;
      }
      return true;
    };

    return BBox;

  })();

  Piece = (function() {
    function Piece(options) {
      var ref, ref1, ref2, ref3, ref4;
      if (options == null) {
        options = {};
      }
      this.size = (ref = options.size) != null ? ref : 2 / 3;
      this.angle = (ref1 = options.angle) != null ? ref1 : Math.PI / 4;
      this.radius = (ref2 = options.radius) != null ? ref2 : 1;
      this.exit = (ref3 = options.exit) != null ? ref3 : 'B';
      this.flip = (ref4 = options.flip) != null ? ref4 : 1;
      this.connections = {
        A: {
          transform: function() {
            return new Transform(0, 0, -180);
          }
        }
      };
      this.section = null;
      this._bbox = null;
    }

    Piece.prototype.setSection = function(section) {
      if (this.section != null) {
        this.section.remove(this);
      }
      section.add(this);
      return section.track._closeLoops(this);
    };

    Piece.prototype.exitTransform = function() {
      return this.connections[this.exit].transform();
    };

    Piece.prototype.draw = function(painter, start) {
      var conn, label, ref;
      ref = this.connections;
      for (label in ref) {
        conn = ref[label];
        painter.drawNobble(start.compound(conn.transform()));
      }
      if (painter.showBBox) {
        return painter.drawRectangle(this._bbox.x1, this._bbox.y1, this._bbox.x2 - this._bbox.x1, this._bbox.y2 - this._bbox.y1);
      }
    };

    Piece.prototype.set = function(property, value) {
      var ref, ref1;
      if (value !== this[property]) {
        this[property] = value;
        return (ref = this.section) != null ? (ref1 = ref.track) != null ? ref1._fire({
          type: 'change',
          target: this
        }) : void 0 : void 0;
      }
    };

    Piece.prototype.hasCollision = function() {
      var idx;
      idx = this.section.track._index(this);
      return this.section.track.collisions().some(function(coll) {
        return coll.indexOf(idx) > -1;
      });
    };

    Piece.prototype._setBBox = function(start) {
      var conn, label, ref, results;
      this._bbox = new BBox;
      ref = this.connections;
      results = [];
      for (label in ref) {
        conn = ref[label];
        results.push(this._bbox.addTransform(start.compound(conn.transform())));
      }
      return results;
    };

    return Piece;

  })();

  Straight = (function(superClass) {
    extend(Straight, superClass);

    function Straight() {
      return Straight.__super__.constructor.apply(this, arguments);
    }

    Straight.prototype.setSection = function(section) {
      this.connections.B = {
        transform: (function(_this) {
          return function() {
            return new Transform(_this.size * section.track.gridSize, 0, 0);
          };
        })(this)
      };
      return Straight.__super__.setSection.apply(this, arguments);
    };

    Straight.prototype.draw = function(painter, start) {
      painter.drawStraight(start, this.size);
      painter.drawStraightRails(start, this.size);
      return Straight.__super__.draw.call(this, painter, start);
    };

    Straight.prototype.clone = function(newsection) {
      var result;
      result = new Straight(this);
      result.setSection(newsection);
      return result;
    };

    return Straight;

  })(Piece);

  Bend = (function(superClass) {
    extend(Bend, superClass);

    function Bend() {
      return Bend.__super__.constructor.apply(this, arguments);
    }

    Bend.prototype.setSection = function(section) {
      this.connections.B = {
        transform: (function(_this) {
          return function() {
            return new Transform(Math.sin(_this.angle) * section.track.gridSize, _this.flip * (1 - Math.cos(_this.angle)) * section.track.gridSize, _this.flip * _this.angle * 180 / Math.PI);
          };
        })(this)
      };
      return Bend.__super__.setSection.apply(this, arguments);
    };

    Bend.prototype.draw = function(painter, start) {
      painter.drawBend(start, start.compound(this.exitTransform()), this.flip);
      painter.drawBendRails(start, start.compound(this.exitTransform()), this.flip);
      return Bend.__super__.draw.call(this, painter, start);
    };

    Bend.prototype.clone = function(newsection) {
      var result;
      result = new Bend(this);
      result.setSection(newsection);
      return result;
    };

    return Bend;

  })(Piece);

  Split = (function(superClass) {
    extend(Split, superClass);

    function Split() {
      return Split.__super__.constructor.apply(this, arguments);
    }

    Split.prototype.setSection = function(section) {
      this.connections.B = {
        transform: (function(_this) {
          return function() {
            return new Transform(_this.size * section.track.gridSize, 0, 0);
          };
        })(this)
      };
      this.connections.C = {
        transform: (function(_this) {
          return function() {
            return new Transform(Math.sin(_this.angle) * section.track.gridSize, _this.flip * (1 - Math.cos(_this.angle)) * section.track.gridSize, _this.flip * _this.angle * 180 / Math.PI);
          };
        })(this)
      };
      return Split.__super__.setSection.apply(this, arguments);
    };

    Split.prototype.draw = function(painter, start) {
      painter.drawStraight(start, this.size);
      painter.drawBend(start, start.compound(this.connections.C.transform()), this.flip);
      painter.drawStraightRails(start, this.size);
      painter.drawBendRails(start, start.compound(this.connections.C.transform()), this.flip);
      return Split.__super__.draw.call(this, painter, start);
    };

    Split.prototype.clone = function(newsection) {
      var result;
      result = new Split(this);
      result.setSection(newsection);
      return result;
    };

    return Split;

  })(Piece);

  Join = (function(superClass) {
    extend(Join, superClass);

    function Join() {
      return Join.__super__.constructor.apply(this, arguments);
    }

    Join.prototype.setSection = function(section) {
      this.connections.B = {
        transform: (function(_this) {
          return function() {
            return new Transform(_this.size * section.track.gridSize, 0, 0);
          };
        })(this)
      };
      this.connections.C = {
        transform: (function(_this) {
          return function() {
            return new Transform(((2 / 3) - Math.sin(_this.angle)) * section.track.gridSize, _this.flip * (1 - Math.cos(_this.angle)) * section.track.gridSize, _this.flip * _this.angle * 3 * 180 / Math.PI);
          };
        })(this)
      };
      return Join.__super__.setSection.apply(this, arguments);
    };

    Join.prototype.draw = function(painter, start) {
      var back;
      painter.drawStraight(start, this.size);
      back = start.compound(this.exitTransform()).compound(new Transform(0, 0, 180));
      painter.drawBend(start.compound(this.connections.C.transform()), back, this.flip);
      painter.drawStraightRails(start, this.size);
      back = start.compound(this.exitTransform()).compound(new Transform(0, 0, 180));
      painter.drawBendRails(start.compound(this.connections.C.transform()), back, this.flip);
      return Join.__super__.draw.call(this, painter, start);
    };

    Join.prototype.clone = function(newsection) {
      var result;
      result = new Join(this);
      result.setSection(newsection);
      return result;
    };

    return Join;

  })(Piece);

  Merge = (function(superClass) {
    extend(Merge, superClass);

    function Merge() {
      return Merge.__super__.constructor.apply(this, arguments);
    }

    Merge.prototype.setSection = function(section) {
      this.connections.B = {
        transform: (function(_this) {
          return function() {
            return new Transform(Math.sin(_this.angle) * section.track.gridSize, _this.flip * (1 - Math.cos(_this.angle)) * section.track.gridSize, _this.flip * _this.angle * 180 / Math.PI);
          };
        })(this)
      };
      this.connections.C = {
        transform: (function(_this) {
          return function() {
            return new Transform(section.track.gridSize * (Math.sin(_this.angle) - (2 * Math.cos(_this.angle) / 3)), _this.flip * section.track.gridSize * (1 - Math.cos(_this.angle) - (2 * Math.sin(_this.angle) / 3)), _this.flip * ((_this.angle * 180 / Math.PI) - 180));
          };
        })(this)
      };
      return Merge.__super__.setSection.apply(this, arguments);
    };

    Merge.prototype.draw = function(painter, start) {
      painter.drawBend(start, start.compound(this.exitTransform()), this.flip);
      painter.drawStraight(start.compound(this.connections.C.transform()).compound(new Transform(0, 0, 180)), this.size);
      painter.drawBendRails(start, start.compound(this.exitTransform()), this.flip);
      painter.drawStraightRails(start.compound(this.connections.C.transform()).compound(new Transform(0, 0, 180)), this.size);
      return Merge.__super__.draw.call(this, painter, start);
    };

    Merge.prototype.clone = function(newsection) {
      var result;
      result = new Merge(this);
      result.setSection(newsection);
      return result;
    };

    return Merge;

  })(Piece);

  Crossover = (function(superClass) {
    extend(Crossover, superClass);

    function Crossover() {
      this.setSection = bind(this.setSection, this);
      return Crossover.__super__.constructor.apply(this, arguments);
    }

    Crossover.prototype.setSection = function(section) {
      this.connections.B = {
        transform: (function(_this) {
          return function() {
            return new Transform(Math.sin(_this.angle) * section.track.gridSize, _this.flip * (1 - Math.cos(_this.angle)) * section.track.gridSize, _this.flip * _this.angle * 180 / Math.PI);
          };
        })(this)
      };
      this.connections.C = {
        transform: (function(_this) {
          return function() {
            return new Transform(2 * section.track.gridSize * Math.sin(_this.angle / 2), _this.flip * 2 * section.track.gridSize * (1 - Math.cos(_this.angle / 2)), 0);
          };
        })(this)
      };
      this.connections.D = {
        transform: (function(_this) {
          return function() {
            return new Transform(section.track.gridSize * (2 * Math.sin(_this.angle / 2) - Math.sin(_this.angle)), _this.flip * section.track.gridSize * (1 - (2 * Math.cos(_this.angle / 2)) + Math.cos(_this.angle)), _this.flip * ((_this.angle * 180 / Math.PI) - 180));
          };
        })(this)
      };
      return Crossover.__super__.setSection.apply(this, arguments);
    };

    Crossover.prototype.draw = function(painter, start) {
      painter.drawBend(start, start.compound(this.exitTransform()), this.flip);
      painter.drawBend(start.compound(this.connections.C.transform()), start.compound(this.connections.D.transform()), this.flip);
      painter.drawBendRails(start, start.compound(this.exitTransform()), this.flip);
      painter.drawBendRails(start.compound(this.connections.C.transform()).compound(new Transform(0, 0, 180)), start.compound(this.connections.D.transform()), this.flip);
      return Crossover.__super__.draw.call(this, painter, start);
    };

    Crossover.prototype.clone = function(newsection) {
      var result;
      result = new Crossover(this);
      result.setSection(newsection);
      return result;
    };

    return Crossover;

  })(Piece);

  transformsMeet = function(t1, t2) {
    return (Math.round(t1.translateX) === Math.round(t2.translateX)) && (Math.round(t1.translateY) === Math.round(t2.translateY)) && (t1.rotateDegs % 360 === (t2.rotateDegs + 180) % 360);
  };

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.Track = Track;

  root.TrackPainter = TrackPainter;

  root.Transform = Transform;

  root.Straight = Straight;

  root.Bend = Bend;

  root.Split = Split;

  root.Join = Join;

  root.Merge = Merge;

  root.Crossover = Crossover;

  root.BBox = BBox;

}).call(this);
