// Generated by CoffeeScript 1.7.1
(function() {
  var BBox, Bend, Crossover, Join, Merge, Piece, Split, Straight, Track, TrackPainter, Transform, root, transformsMeet,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Track = (function() {
    var Section;

    function Track(start, options) {
      var _ref, _ref1, _ref2;
      this.start = start != null ? start : new Transform(0, 0, 0);
      if (options == null) {
        options = {};
      }
      this.gridSize = (_ref = options.gridSize) != null ? _ref : 100;
      this.trackWidth = (_ref1 = options.trackWidth) != null ? _ref1 : 16;
      this.trackGap = (_ref2 = options.trackGap) != null ? _ref2 : 1;
      this._sections = [];
      this._listeners = {};
      this._gapTransform = new Transform(this.trackGap, 0, 0);
      this.started = null;
    }

    Track.prototype.on = function(types, listener) {
      return types.split(" ").forEach((function(_this) {
        return function(type) {
          if (_this._listeners[type] == null) {
            _this._listeners[type] = [];
          }
          return _this._listeners[type].push(listener);
        };
      })(this));
    };

    Track.prototype.off = function(types, listener) {
      return types.split(" ").forEach((function(_this) {
        return function(type) {
          var idx, l, _i, _len, _ref, _results;
          _ref = _this._listeners[type];
          _results = [];
          for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
            l = _ref[idx];
            if (l === listener) {
              _results.push(_this._listeners[type].splice(idx, 1));
            }
          }
          return _results;
        };
      })(this));
    };

    Track.prototype._fire = function(event) {
      if (typeof event === "string") {
        event = {
          type: event
        };
      }
      if (!event.target) {
        event.target = this;
      }
      if (!event.type) {
        throw new Error("Event missing 'type' property.");
      }
      if (this._listeners[event.type] instanceof Array) {
        return this._listeners[event.type].forEach(function(listener) {
          return listener.call(this, event);
        });
      }
    };

    Track.prototype.set = function(property, value) {
      if (value !== this[property]) {
        this[property] = value;
        switch (property) {
          case 'trackGap':
            this._gapTransform = new Transform(value, 0, 0);
        }
        return this._fire({
          type: 'change',
          target: this
        });
      }
    };

    Track.prototype.clone = function() {
      var result, section, _i, _len, _ref;
      result = new Track(this.start, this);
      _ref = this._sections;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        section = _ref[_i];
        result._sections.push(section.clone(result));
      }
      return result;
    };

    Track.prototype.connections = function() {
      var offset, result;
      result = [];
      offset = 0;
      this._sections.forEach(function(section) {
        section.connections().forEach(function(code) {
          var index, letter, _ref;
          _ref = code.split(':'), index = _ref[0], letter = _ref[1];
          return result.push((parseInt(index) + offset).toString() + ":" + letter);
        });
        return offset += section._pieces.length;
      });
      return result;
    };

    Track.prototype.pieces = function() {
      var result;
      result = [];
      this._sections.forEach(function(section) {
        return result = result.concat(section._pieces);
      });
      return result;
    };

    Track.prototype.add = function(piece, where) {
      var section;
      if (where != null) {
        section = this._createSection(function() {
          return where;
        });
        piece.setSection(section);
        return this._firePieceAdded(piece);
      } else if (this.connections().length === 0 && (this.started == null)) {
        section = this._createSection((function(_this) {
          return function() {
            return _this.start;
          };
        })(this));
        piece.setSection(section);
        this._firePieceAdded(piece);
        return this.started = piece;
      } else if (this.cursor() != null) {
        return this.connect(piece, this.cursor());
      } else {
        throw new Error('unable to add piece - try specifying the where parameter in the track.add method');
      }
    };

    Track.prototype.cursor = function() {
      var code, conns, piece, section;
      section = this._sections[this._sections.length - 1];
      if (section != null) {
        piece = section._pieces[section._pieces.length - 1];
      }
      if (piece != null) {
        code = this._index(piece) + ":" + piece.exit;
      }
      conns = this.connections();
      if ((code != null) && conns.indexOf(code) > -1) {
        return code;
      } else {
        return conns.pop();
      }
    };

    Track.prototype.connect = function(piece, code) {
      var added, index, label, section, sectionIndex, sectionPieceIndex, _ref, _ref1;
      if (this.connections().indexOf(code) > -1) {
        added = false;
        this._sections.forEach((function(_this) {
          return function(section) {
            var last, lastExit, length;
            length = section._pieces.length;
            last = section._pieces[length - 1];
            lastExit = (_this._sectionStartingIndex(section) + length - 1) + ":" + last.exit;
            if (lastExit === code) {
              added = true;
              piece.setSection(section);
              return _this._firePieceAdded(piece);
            }
          };
        })(this));
        if (!added) {
          _ref = code.split(':'), index = _ref[0], label = _ref[1];
          _ref1 = this._sectionAndPieceIndex(index), sectionIndex = _ref1[0], sectionPieceIndex = _ref1[1];
          section = this._createSection((function(_this) {
            return function() {
              return _this._sections[sectionIndex].compoundTransform(sectionPieceIndex, label).compound(_this._gapTransform);
            };
          })(this));
          this._connection(code).connected = piece.connections['A'];
          piece.connections['A'].connected = this._connection(code);
          piece.setSection(section);
          return this._firePieceAdded(piece);
        }
      } else {
        throw new Error(code + " is not an available connection");
      }
    };

    Track.prototype.remove = function(index) {
      var pieceIndex, sectionIndex, _ref;
      _ref = this._sectionAndPieceIndex(index), sectionIndex = _ref[0], pieceIndex = _ref[1];
      this._sections[sectionIndex].remove(pieceIndex);
      return this._fire({
        type: 'remove',
        target: this
      });
    };

    Track.prototype.clear = function() {
      this._sections = [];
      this._fire({
        type: 'clear',
        target: this
      });
      return this.started = null;
    };

    Track.prototype.collisions = function() {
      var idx, idx2, pieces, result, source, target, _i, _j, _len, _len1, _ref;
      pieces = [];
      this._sections.forEach((function(_this) {
        return function(section) {
          var start;
          start = section.transform();
          return section._pieces.forEach(function(piece) {
            piece._setBBox(start);
            start = start.compound(piece.exitTransform()).compound(_this._gapTransform);
            return pieces.push(piece);
          });
        };
      })(this));
      result = [];
      for (idx = _i = 0, _len = pieces.length; _i < _len; idx = ++_i) {
        source = pieces[idx];
        _ref = pieces.slice(idx + 1);
        for (idx2 = _j = 0, _len1 = _ref.length; _j < _len1; idx2 = ++_j) {
          target = _ref[idx2];
          if (source._bbox.overlaps(target._bbox)) {
            result.push([idx, idx2 + idx + 1]);
          }
        }
      }
      return result;
    };

    Track.prototype.hasCollision = function() {
      return this.collisions().length > 0;
    };

    Track.prototype.connected = function(a, b) {
      var connection, label, _ref;
      _ref = a.connections;
      for (label in _ref) {
        connection = _ref[label];
        if (connection.connected === b) {
          return true;
        }
      }
      return false;
    };

    Track.prototype._firePieceAdded = function(piece) {
      var idx, transform;
      idx = this._index(piece);
      transform = this._transform(idx.toString() + ":A");
      return this._fire({
        type: 'add',
        target: piece,
        start: transform.compound(new Transform(0, 0, 180))
      });
    };

    Track.prototype._sectionAndPieceIndex = function(index) {
      var result, sectionIdx;
      result = null;
      sectionIdx = 0;
      this._sections.forEach(function(section) {
        if (index < section._pieces.length && (result == null)) {
          return result = [sectionIdx, index];
        } else {
          index -= section._pieces.length;
          return sectionIdx++;
        }
      });
      return result;
    };

    Track.prototype._sectionStartingIndex = function(section) {
      var idx, result, _fn, _i, _ref;
      result = 0;
      if (this._sections.length > 0) {
        _fn = (function(_this) {
          return function(idx) {
            return result += _this._sections[idx]._pieces.length;
          };
        })(this);
        for (idx = _i = 0, _ref = this._sections.indexOf(section); 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
          _fn(idx);
        }
      }
      return result;
    };

    Track.prototype._index = function(piece) {
      var idx, p, result, _i, _len, _ref;
      result = -1;
      _ref = this.pieces();
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        p = _ref[idx];
        if (piece === p) {
          result = idx;
        }
      }
      return result;
    };

    Track.prototype._piece = function(index) {
      var pieceidx, sectionidx, _ref;
      _ref = {
        _sectionAndPieceIndex: index
      }, sectionidx = _ref[0], pieceidx = _ref[1];
      return this._sections[sectionidx]._pieces[pieceidx];
    };

    Track.prototype._connection = function(code) {
      var index, letter, sectionIndex, sectionPieceIndex, _ref, _ref1;
      _ref = code.split(':'), index = _ref[0], letter = _ref[1];
      _ref1 = this._sectionAndPieceIndex(parseInt(index)), sectionIndex = _ref1[0], sectionPieceIndex = _ref1[1];
      return this._sections[sectionIndex]._pieces[sectionPieceIndex].connections[letter];
    };

    Track.prototype._createSection = function(transform) {
      var section;
      if (transform == null) {
        transform = null;
      }
      section = new Section(this, transform);
      this._sections.push(section);
      return section;
    };

    Track.prototype._closeLoops = function() {
      var loose, _i, _ref, _results;
      loose = this.connections();
      return (function() {
        _results = [];
        for (var _i = 0, _ref = loose.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).forEach((function(_this) {
        return function(idx1) {
          var _i, _ref, _ref1, _results;
          return (function() {
            _results = [];
            for (var _i = _ref = idx1 + 1, _ref1 = loose.length; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; _ref <= _ref1 ? _i++ : _i--){ _results.push(_i); }
            return _results;
          }).apply(this).forEach(function(idx2) {
            var trans1, trans2;
            trans1 = _this._transform(loose[idx1]);
            trans2 = _this._transform(loose[idx2]).compound(_this._gapTransform);
            if (transformsMeet(trans1, trans2)) {
              _this._connection(loose[idx1]).connected = _this._connection(loose[idx2]);
              _this._connection(loose[idx2]).connected = _this._connection(loose[idx1]);
              return _this._closeLoops;
            }
          });
        };
      })(this));
    };

    Track.prototype._transform = function(code) {
      var index, label, sectionIndex, sectionPieceIndex, _ref, _ref1;
      _ref = code.split(':'), index = _ref[0], label = _ref[1];
      _ref1 = this._sectionAndPieceIndex(index), sectionIndex = _ref1[0], sectionPieceIndex = _ref1[1];
      return this._sections[sectionIndex].compoundTransform(sectionPieceIndex, label);
    };

    Section = (function() {
      function Section(track, transform) {
        this.track = track;
        this.transform = transform != null ? transform : function() {
          return new Transform(0, 0, 0);
        };
        this._pieces = [];
        this.exit = null;
      }

      Section.prototype.clone = function(newtrack) {
        var piece, result, _i, _len, _ref;
        result = new Section(newtrack, this.transform);
        _ref = this._pieces;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          piece = _ref[_i];
          piece.clone(result);
        }
        return result;
      };

      Section.prototype.add = function(piece) {
        var num_pieces, section_offset;
        if (this._pieces.length > 0 && this.connections().length === 0) {
          throw new Error("No available connections on this section");
        }
        num_pieces = this._pieces.length;
        section_offset = this.track._sectionStartingIndex(this);
        piece.section = this;
        if (this.exit != null) {
          this.exit.connected = piece;
          piece.connections['A'].connected = this;
        }
        this.exit = piece.connections[piece.exit];
        this._pieces.push(piece);
        return piece;
      };

      Section.prototype.remove = function(idx) {
        var num_pieces, removee;
        if (typeof idx !== "number") {
          idx = this._pieces.indexOf(idx);
        }
        num_pieces = this._pieces.length;
        if (idx >= 0 && idx < num_pieces) {
          removee = this._pieces[idx];
          if (num_pieces > 1) {
            if (idx < (num_pieces - 1)) {
              this._pieces[idx + 1].connections['A'].connected = removee.connections['A'].connected;
            }
            if (idx > 0) {
              this._pieces[idx - 1].connections[this._pieces[idx - 1].exit].connected = removee.connections[removee.exit].connected;
            }
            removee.connections['A'].connected = null;
            removee.connections[removee.exit].connected = null;
          } else {
            this.exit = null;
          }
          this._pieces[idx].section = null;
          return this._pieces.splice(idx, 1);
        } else {
          throw new Error("Cannot remove piece " + idx + " from section with " + this._pieces.length + " pieces");
        }
      };

      Section.prototype.connections = function() {
        var connection, idx, label, piece, result, _i, _len, _ref, _ref1;
        result = [];
        _ref = this._pieces;
        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
          piece = _ref[idx];
          _ref1 = piece.connections;
          for (label in _ref1) {
            connection = _ref1[label];
            if (!connection.connected) {
              result.push(idx.toString() + ":" + label);
            }
          }
        }
        return result;
      };

      Section.prototype.compoundTransform = function(n, connection) {
        var start, _i, _results;
        start = this.transform();
        (function() {
          _results = [];
          for (var _i = 0; 0 <= n ? _i < n : _i > n; 0 <= n ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this).forEach((function(_this) {
          return function(pieceIndex) {
            return start = start.compound(_this._pieces[pieceIndex].exitTransform()).compound(_this.track._gapTransform);
          };
        })(this));
        return start.compound(this._pieces[n].connections[connection].transform());
      };

      return Section;

    })();

    return Track;

  })();

  TrackPainter = (function() {
    function TrackPainter(track, options) {
      var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      if (options == null) {
        options = {};
      }
      this.track = track;
      this.trackColor = (_ref = options.trackColor) != null ? _ref : "lightgrey";
      this.railColor = (_ref1 = options.railColor) != null ? _ref1 : "white";
      this.showCodes = (_ref2 = options.showCodes) != null ? _ref2 : true;
      this.showCursor = (_ref3 = options.showCursor) != null ? _ref3 : true;
      this.railWidth = (_ref4 = options.railWidth) != null ? _ref4 : 2;
      this.railGauge = (_ref5 = options.railGauge) != null ? _ref5 : 9;
      this.showBBox = (_ref6 = options.showBBox) != null ? _ref6 : false;
      this.draw();
    }

    TrackPainter.prototype.draw = function() {
      this._clear();
      this.track._sections.forEach((function(_this) {
        return function(section) {
          var start;
          start = section.transform();
          return section._pieces.forEach(function(piece) {
            if (_this.showBBox) {
              piece._setBBox;
            }
            piece.draw(_this, start);
            return start = start.compound(piece.exitTransform()).compound(_this.track._gapTransform);
          });
        };
      })(this));
      if (this.showCodes) {
        this.track.connections().forEach((function(_this) {
          return function(code) {
            return _this.drawCode(_this.track._transform(code).compound(_this.track._gapTransform), code);
          };
        })(this));
      }
      if (this.showCursor && this.track.cursor()) {
        return this.drawCursor(this.track._transform(this.track.cursor()));
      }
    };

    TrackPainter.prototype.set = function(property, value) {
      if (value !== this[property]) {
        this[property] = value;
        return this.draw();
      }
    };

    return TrackPainter;

  })();

  Transform = (function() {
    function Transform(translateX, translateY, rotateDegs) {
      this.translateX = translateX;
      this.translateY = translateY;
      this.rotateDegs = rotateDegs;
      this.rotateRads = this.rotateDegs * Math.PI / 180;
    }

    Transform.prototype.compound = function(transform) {
      return new Transform(this.translateX + Math.cos(this.rotateRads) * transform.translateX - Math.sin(this.rotateRads) * transform.translateY, this.translateY + Math.sin(this.rotateRads) * transform.translateX + Math.cos(this.rotateRads) * transform.translateY, (360 + this.rotateDegs + transform.rotateDegs) % 360);
    };

    Transform.prototype.toString = function() {
      return "(" + this.translateX + ", " + this.translateY + ", " + this.rotateDegs + ")";
    };

    return Transform;

  })();

  BBox = (function() {
    function BBox() {}

    BBox.prototype.addTransform = function(t) {
      if ((this.x1 == null) || t.translateX < this.x1) {
        this.x1 = t.translateX;
      }
      if ((this.x2 == null) || t.translateX > this.x2) {
        this.x2 = t.translateX;
      }
      if ((this.y1 == null) || t.translateY < this.y1) {
        this.y1 = t.translateY;
      }
      if ((this.y2 == null) || t.translateY > this.y2) {
        return this.y2 = t.translateY;
      }
    };

    BBox.prototype.overlaps = function(bbox) {
      if (bbox.x2 < this.x1) {
        return false;
      }
      if (bbox.x1 > this.x2) {
        return false;
      }
      if (bbox.y2 < this.y1) {
        return false;
      }
      if (bbox.y1 > this.y2) {
        return false;
      }
      return true;
    };

    return BBox;

  })();

  Piece = (function() {
    function Piece(options) {
      var _ref, _ref1, _ref2, _ref3, _ref4;
      if (options == null) {
        options = {};
      }
      this.size = (_ref = options.size) != null ? _ref : 2 / 3;
      this.angle = (_ref1 = options.angle) != null ? _ref1 : Math.PI / 4;
      this.radius = (_ref2 = options.radius) != null ? _ref2 : 1;
      this.exit = (_ref3 = options.exit) != null ? _ref3 : 'B';
      this.flip = (_ref4 = options.flip) != null ? _ref4 : 1;
      this.connections = {
        A: {
          transform: function() {
            return new Transform(0, 0, -180);
          }
        }
      };
      this.section = null;
      this._bbox = null;
    }

    Piece.prototype.setSection = function(section) {
      if (this.section != null) {
        this.section.remove(this);
      }
      section.add(this);
      return section.track._closeLoops(this);
    };

    Piece.prototype.exitTransform = function() {
      return this.connections[this.exit].transform();
    };

    Piece.prototype.draw = function(painter, start) {
      var conn, label, _ref;
      _ref = this.connections;
      for (label in _ref) {
        conn = _ref[label];
        painter.drawNobble(start.compound(conn.transform()));
      }
      if (painter.showBBox) {
        return painter.drawRectangle(this._bbox.x1, this._bbox.y1, this._bbox.x2 - this._bbox.x1, this._bbox.y2 - this._bbox.y1);
      }
    };

    Piece.prototype.set = function(property, value) {
      var _ref, _ref1;
      if (value !== this[property]) {
        this[property] = value;
        return (_ref = this.section) != null ? (_ref1 = _ref.track) != null ? _ref1._fire({
          type: 'change',
          target: this
        }) : void 0 : void 0;
      }
    };

    Piece.prototype.hasCollision = function() {
      var idx;
      idx = this.section.track._index(this);
      return this.section.track.collisions().some(function(coll) {
        return coll.indexOf(idx) > -1;
      });
    };

    Piece.prototype._setBBox = function(start) {
      var conn, label, _ref, _results;
      this._bbox = new BBox;
      _ref = this.connections;
      _results = [];
      for (label in _ref) {
        conn = _ref[label];
        _results.push(this._bbox.addTransform(start.compound(conn.transform())));
      }
      return _results;
    };

    return Piece;

  })();

  Straight = (function(_super) {
    __extends(Straight, _super);

    function Straight() {
      return Straight.__super__.constructor.apply(this, arguments);
    }

    Straight.prototype.setSection = function(section) {
      this.connections.B = {
        transform: (function(_this) {
          return function() {
            return new Transform(_this.size * section.track.gridSize, 0, 0);
          };
        })(this)
      };
      return Straight.__super__.setSection.apply(this, arguments);
    };

    Straight.prototype.draw = function(painter, start) {
      painter.drawStraight(start, this.size);
      painter.drawStraightRails(start, this.size);
      return Straight.__super__.draw.call(this, painter, start);
    };

    Straight.prototype.clone = function(newsection) {
      var result;
      result = new Straight(this);
      result.setSection(newsection);
      return result;
    };

    return Straight;

  })(Piece);

  Bend = (function(_super) {
    __extends(Bend, _super);

    function Bend() {
      return Bend.__super__.constructor.apply(this, arguments);
    }

    Bend.prototype.setSection = function(section) {
      this.connections.B = {
        transform: (function(_this) {
          return function() {
            return new Transform(Math.sin(_this.angle) * section.track.gridSize, _this.flip * (1 - Math.cos(_this.angle)) * section.track.gridSize, _this.flip * _this.angle * 180 / Math.PI);
          };
        })(this)
      };
      return Bend.__super__.setSection.apply(this, arguments);
    };

    Bend.prototype.draw = function(painter, start) {
      painter.drawBend(start, start.compound(this.exitTransform()), this.flip);
      painter.drawBendRails(start, start.compound(this.exitTransform()), this.flip);
      return Bend.__super__.draw.call(this, painter, start);
    };

    Bend.prototype.clone = function(newsection) {
      var result;
      result = new Bend(this);
      result.setSection(newsection);
      return result;
    };

    return Bend;

  })(Piece);

  Split = (function(_super) {
    __extends(Split, _super);

    function Split() {
      return Split.__super__.constructor.apply(this, arguments);
    }

    Split.prototype.setSection = function(section) {
      this.connections.B = {
        transform: (function(_this) {
          return function() {
            return new Transform(_this.size * section.track.gridSize, 0, 0);
          };
        })(this)
      };
      this.connections.C = {
        transform: (function(_this) {
          return function() {
            return new Transform(Math.sin(_this.angle) * section.track.gridSize, _this.flip * (1 - Math.cos(_this.angle)) * section.track.gridSize, _this.flip * _this.angle * 180 / Math.PI);
          };
        })(this)
      };
      return Split.__super__.setSection.apply(this, arguments);
    };

    Split.prototype.draw = function(painter, start) {
      painter.drawStraight(start, this.size);
      painter.drawBend(start, start.compound(this.connections.C.transform()), this.flip);
      painter.drawStraightRails(start, this.size);
      painter.drawBendRails(start, start.compound(this.connections.C.transform()), this.flip);
      return Split.__super__.draw.call(this, painter, start);
    };

    Split.prototype.clone = function(newsection) {
      var result;
      result = new Split(this);
      result.setSection(newsection);
      return result;
    };

    return Split;

  })(Piece);

  Join = (function(_super) {
    __extends(Join, _super);

    function Join() {
      return Join.__super__.constructor.apply(this, arguments);
    }

    Join.prototype.setSection = function(section) {
      this.connections.B = {
        transform: (function(_this) {
          return function() {
            return new Transform(_this.size * section.track.gridSize, 0, 0);
          };
        })(this)
      };
      this.connections.C = {
        transform: (function(_this) {
          return function() {
            return new Transform(((2 / 3) - Math.sin(_this.angle)) * section.track.gridSize, _this.flip * (1 - Math.cos(_this.angle)) * section.track.gridSize, _this.flip * _this.angle * 3 * 180 / Math.PI);
          };
        })(this)
      };
      return Join.__super__.setSection.apply(this, arguments);
    };

    Join.prototype.draw = function(painter, start) {
      var back;
      painter.drawStraight(start, this.size);
      back = start.compound(this.exitTransform()).compound(new Transform(0, 0, 180));
      painter.drawBend(start.compound(this.connections.C.transform()), back, this.flip);
      painter.drawStraightRails(start, this.size);
      back = start.compound(this.exitTransform()).compound(new Transform(0, 0, 180));
      painter.drawBendRails(start.compound(this.connections.C.transform()), back, this.flip);
      return Join.__super__.draw.call(this, painter, start);
    };

    Join.prototype.clone = function(newsection) {
      var result;
      result = new Join(this);
      result.setSection(newsection);
      return result;
    };

    return Join;

  })(Piece);

  Merge = (function(_super) {
    __extends(Merge, _super);

    function Merge() {
      return Merge.__super__.constructor.apply(this, arguments);
    }

    Merge.prototype.setSection = function(section) {
      this.connections.B = {
        transform: (function(_this) {
          return function() {
            return new Transform(Math.sin(_this.angle) * section.track.gridSize, _this.flip * (1 - Math.cos(_this.angle)) * section.track.gridSize, _this.flip * _this.angle * 180 / Math.PI);
          };
        })(this)
      };
      this.connections.C = {
        transform: (function(_this) {
          return function() {
            return new Transform(section.track.gridSize * (Math.sin(_this.angle) - (2 * Math.cos(_this.angle) / 3)), _this.flip * section.track.gridSize * (1 - Math.cos(_this.angle) - (2 * Math.sin(_this.angle) / 3)), _this.flip * ((_this.angle * 180 / Math.PI) - 180));
          };
        })(this)
      };
      return Merge.__super__.setSection.apply(this, arguments);
    };

    Merge.prototype.draw = function(painter, start) {
      painter.drawBend(start, start.compound(this.exitTransform()), this.flip);
      painter.drawStraight(start.compound(this.connections.C.transform()).compound(new Transform(0, 0, 180)), this.size);
      painter.drawBendRails(start, start.compound(this.exitTransform()), this.flip);
      painter.drawStraightRails(start.compound(this.connections.C.transform()).compound(new Transform(0, 0, 180)), this.size);
      return Merge.__super__.draw.call(this, painter, start);
    };

    Merge.prototype.clone = function(newsection) {
      var result;
      result = new Merge(this);
      result.setSection(newsection);
      return result;
    };

    return Merge;

  })(Piece);

  Crossover = (function(_super) {
    __extends(Crossover, _super);

    function Crossover() {
      this.setSection = __bind(this.setSection, this);
      return Crossover.__super__.constructor.apply(this, arguments);
    }

    Crossover.prototype.setSection = function(section) {
      this.connections.B = {
        transform: (function(_this) {
          return function() {
            return new Transform(Math.sin(_this.angle) * section.track.gridSize, _this.flip * (1 - Math.cos(_this.angle)) * section.track.gridSize, _this.flip * _this.angle * 180 / Math.PI);
          };
        })(this)
      };
      this.connections.C = {
        transform: (function(_this) {
          return function() {
            return new Transform(2 * section.track.gridSize * Math.sin(_this.angle / 2), _this.flip * 2 * section.track.gridSize * (1 - Math.cos(_this.angle / 2)), 0);
          };
        })(this)
      };
      this.connections.D = {
        transform: (function(_this) {
          return function() {
            return new Transform(section.track.gridSize * (2 * Math.sin(_this.angle / 2) - Math.sin(_this.angle)), _this.flip * section.track.gridSize * (1 - (2 * Math.cos(_this.angle / 2)) + Math.cos(_this.angle)), _this.flip * ((_this.angle * 180 / Math.PI) - 180));
          };
        })(this)
      };
      return Crossover.__super__.setSection.apply(this, arguments);
    };

    Crossover.prototype.draw = function(painter, start) {
      painter.drawBend(start, start.compound(this.exitTransform()), this.flip);
      painter.drawBend(start.compound(this.connections.C.transform()), start.compound(this.connections.D.transform()), this.flip);
      painter.drawBendRails(start, start.compound(this.exitTransform()), this.flip);
      painter.drawBendRails(start.compound(this.connections.C.transform()).compound(new Transform(0, 0, 180)), start.compound(this.connections.D.transform()), this.flip);
      return Crossover.__super__.draw.call(this, painter, start);
    };

    Crossover.prototype.clone = function(newsection) {
      var result;
      result = new Crossover(this);
      result.setSection(newsection);
      return result;
    };

    return Crossover;

  })(Piece);

  transformsMeet = function(t1, t2) {
    return (Math.round(t1.translateX) === Math.round(t2.translateX)) && (Math.round(t1.translateY) === Math.round(t2.translateY)) && (t1.rotateDegs % 360 === (t2.rotateDegs + 180) % 360);
  };

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.Track = Track;

  root.TrackPainter = TrackPainter;

  root.Transform = Transform;

  root.Straight = Straight;

  root.Bend = Bend;

  root.Split = Split;

  root.Join = Join;

  root.Merge = Merge;

  root.Crossover = Crossover;

}).call(this);
